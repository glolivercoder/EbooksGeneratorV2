"""
FastAPI Application Principal
Endpoints para geração de ebooks, pesquisa, imagens e configuração
"""
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import uvicorn

from config.settings import settings
from services.env_manager import env_manager

app = FastAPI(
    title="Ebook Generator API",
    description="API para geração de ebooks técnicos de alta qualidade com RAG e agentes inteligentes",
    version="1.0.0"
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # TODO: Restringir em produção
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ==================== Models ====================

class EbookConfig(BaseModel):
    """Configuração para geração de ebook"""
    topic: str
    target_audience: str
    num_chapters: int
    depth_level: int  # 1-5
    language: str = "pt-BR"
    citation_style: str = "ABNT"


class ChapterConfig(BaseModel):
    """Configuração para geração de capítulo individual"""
    chapter_number: int
    chapter_title: str
    topic: str
    context: Optional[str] = None


class APIKeyUpdate(BaseModel):
    """Atualização de chaves API"""
    key_name: str
    key_value: str


class ConnectionTest(BaseModel):
    """Resultado de teste de conexão"""
    service: str
    status: str
    message: Optional[str] = None


# ==================== Health Check ====================

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "version": "1.0.0",
        "environment": settings.env
    }


# ==================== Configuration Endpoints ====================

@app.post("/api/config/test-connection", response_model=List[ConnectionTest])
async def test_all_connections():
    """Testa conexão com todas as APIs configuradas"""
    from services.llm_client import llm_client
    
    results = []
    
    # Test LLMs (OpenRouter + Gemini)
    try:
        llm_test = await llm_client.test_connection()
        
        if llm_test.get("openrouter"):
            results.append(ConnectionTest(
                service="OpenRouter",
                status="connected",
                message="Conexão OK - LLMs disponíveis"
            ))
        else:
            results.append(ConnectionTest(
                service="OpenRouter",
                status="not_configured",
                message="Chave API não configurada ou inválida"
            ))
        
        if llm_test.get("gemini"):
            results.append(ConnectionTest(
                service="Gemini",
                status="connected",
                message="Conexão OK"
            ))
        else:
            results.append(ConnectionTest(
                service="Gemini",
                status="not_configured",
                message="Chave API não configurada ou inválida"
            ))
    except Exception as e:
        results.append(ConnectionTest(
            service="LLMs",
            status="error",
            message=f"Erro: {str(e)}"
        ))
    
    # Test Pixabay
    pixabay_test = settings.test_pixabay_connection()
    results.append(ConnectionTest(
        service="Pixabay",
        status=pixabay_test["status"],
        message="Configurado" if pixabay_test["status"] == "connected" else "Chave API não configurada"
    ))
    
    return results


@app.put("/api/config/update-keys")
async def update_api_keys(updates: List[APIKeyUpdate]):
    """
    Atualiza chaves API no arquivo .env
    Cria backup automático antes de modificar
    """
    results = {}
    
    for update in updates:
        success = env_manager.update_key(
            key=update.key_name.upper(),
            value=update.key_value
        )
        results[update.key_name] = "updated" if success else "failed"
    
    # Recarregar settings
    from importlib import reload
    from config import settings as settings_module
    reload(settings_module)
    
    return {
        "status": "completed",
        "results": results
    }


# ==================== Generation Endpoints ====================

@app.post("/api/generate/ebook")
async def generate_ebook(config: EbookConfig, background_tasks: BackgroundTasks):
    """
    Gera ebook completo com múltiplos capítulos
    Processo assíncrono com streaming de progresso
    """
    # TODO: Implementar geração completa
    return {
        "status": "started",
        "message": "Geração de ebook iniciada",
        "task_id": "ebook_123",  # Placeholder
        "config": config.model_dump()
    }


@app.post("/api/generate/chapter")
async def generate_chapter(config: ChapterConfig):
    """
    Gera um capítulo individual usando orquestrador
    """
    from agents.orchestrator import orchestrator
    
    try:
        result = await orchestrator.generate_chapter(
            book_id=f"book_{config.chapter_number}",  # TODO: ID real do livro
            chapter_number=config.chapter_number,
            chapter_title=config.chapter_title,
            topic=config.topic,
            target_audience=config.context or "estudantes de graduação"
        )
        
        return {
            "status": "success",
            "chapter": result
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/research/deep")
async def deep_research(query: str, academic_only: bool = True):
    """
    Executa pesquisa profunda sobre um tema
    Retorna fontes verificadas e síntese
    """
    from agents.deep_research import research_agent
    
    try:
        results = await research_agent.research(
            query=query,
            academic_only=academic_only,
            max_results=10,
            min_year=2020
        )
        
        return {
            "status": "completed",
            "query": query,
            "sources_count": results["sources_count"],
            "sources": results["sources"],
            "synthesis": results["synthesis"]
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# ==================== Image Endpoints ====================

@app.post("/api/images/generate")
async def generate_image(prompt: str, model: Optional[str] = None):
    """
    Gera imagem via OpenRouter
    """
    # TODO: Implementar geração de imagem
    return {
        "status": "pending",
        "prompt": prompt,
        "model": model or settings.image_model
    }


@app.get("/api/images/pixabay")
async def search_pixabay_images(query: str, per_page: int = 10):
    """
    Busca imagens no Pixabay
    """
    # TODO: Implementar busca no Pixabay
    return {
        "query": query,
        "results": [],
        "total": 0
    }


# ==================== Dynamic Agent Endpoints ====================

@app.post("/api/agents/create")
async def create_agent_dynamically(spec: Dict[str, Any]):
    """
    Cria um agente especializado dinamicamente
    Instala bibliotecas necessárias
    """
    # TODO: Implementar criação dinâmica de agentes
    return {
        "status": "created",
        "agent_name": spec.get("name", "unknown"),
        "message": "Implementação pendente"
    }


# ==================== Main ====================

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=settings.backend_port,
        reload=settings.env == "development"
    )
